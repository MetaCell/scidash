webpackJsonp([12],{

/***/ 1035:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/**\n * Controller class for plotting widget. Use to make calls to widget from inside Geppetto.\n *\n * @author Jesus R Martinez (jesus@metacell.us)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(1137);\n\n    /**\n     * @exports Widgets/Plotly/PlotlyController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = [];\n            var widgets = this.widgets;\n        },\n\n        /**\n         * Creates plotting widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(29).then((function (require) {\n                    var Plot = __webpack_require__(1318);\n\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"Plot\", that.widgets);\n                    var name = id;\n\n                    //create plotting widget\n                    var p = window[name] = new Plot({\n                        id: id, name: name, visible: true,\n                        widgetType: GEPPETTO.Widgets.PLOT,\n                        stateless: isStateless\n                    });\n                    p.setController(that);\n                    p.setSize(p.defaultSize().height, p.defaultSize().width);\n\n                    //create help command for plot\n                    p.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    //store in local stack\n                    that.widgets.push(p);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //add commands to console autocomplete and help option\n                    GEPPETTO.CommandController.updateHelpCommand(p, id, that.getFileComments(\"geppetto/js/components/widgets/plot/Plot.js\"));\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(p.getId(), p);\n\n                    resolve(p);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        isColorbar: function isColorbar(plot) {\n            return plot.datasets[0] != undefined && plot.datasets[0].type == \"heatmap\";\n        },\n\n        /**\n         * Receives updates from widget listener class to update plotting widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event, parameters) {\n            //delete plot widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n\n            //reset plot's datasets\n            else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.RESET_DATA) {\n                    for (var i = 0; i < this.widgets.length; i++) {\n                        var plot = this.widgets[i];\n\n                        plot.cleanDataSets();\n                    }\n                }\n\n                //update plotting widgets\n                else if (event == GEPPETTO.Events.Experiment_play) {\n                        for (var i = 0; i < this.widgets.length; i++) {\n                            var plot = this.widgets[i];\n                            if (!this.isColorbar(plot) && plot.datasets.length > 0) plot.clean(parameters.playAll);\n                        }\n                    }\n\n                    //update plotting widgets\n                    else if (event == GEPPETTO.Events.Experiment_over) {}\n\n                        //update plotting widgets\n                        else if (event == GEPPETTO.Events.Experiment_update) {\n\n                                //loop through all existing widgets\n                                for (var i = 0; i < this.widgets.length; i++) {\n                                    var plot = this.widgets[i];\n                                    //we need the playAll parameter here because the plot might be coming up after the play\n                                    //event was triggered and in that case we need to catch up knowing what kind of play\n                                    //it's happening\n                                    if (!this.isColorbar(plot) && plot.datasets.length > 0) plot.updateDataSet(parameters.step, parameters.playAll);\n                                }\n                            } else if (event == GEPPETTO.Events.Lit_entities_changed) {\n                                for (var i = 0; i < this.widgets.length; i++) {\n                                    var plot = this.widgets[i];\n                                    if (this.isColorbar(plot) &&\n                                    // prevent plots from being destroyed when views are loading\n                                    !GEPPETTO.Spinner.visible) {\n                                        plot.destroy();\n                                    }\n                                }\n                            }\n        },\n\n        /**\n         * Retrieve commands for a specific variable node\n         *\n         * @param {Node} node - Geppetto Node used for extracting commands\n         * @returns {Array} Set of commands associated with this node\n         */\n        getCommands: function getCommands(node) {\n            var groups = [];\n\n            if (node.getWrappedObj().getType().getMetaType() == GEPPETTO.Resources.DYNAMICS_TYPE) {\n                if (node.getWrappedObj().getInitialValues()[0].value.dynamics.functionPlot != undefined) {\n                    var group1 = [{\n                        label: \"Plot Function\",\n                        action: [\"G.addWidget(Widgets.PLOT).then(w=>{w.plotFunctionNode(\" + node.getPath() + \"); w.setSize(200,450);});\"]\n                    }];\n\n                    var availableWidgets = GEPPETTO.WidgetFactory.getController(GEPPETTO.Widgets.PLOT).getWidgets();\n                    if (availableWidgets.length > 0) {\n                        var group1Add = {\n                            label: \"Add to Plot Widget\",\n                            position: 0\n                        };\n\n                        var subgroups1Add = [];\n                        for (var availableWidgetIndex in availableWidgets) {\n                            var availableWidget = availableWidgets[availableWidgetIndex];\n                            subgroups1Add = subgroups1Add.concat([{\n                                label: \"Add to \" + availableWidget.name,\n                                action: [availableWidget.id + \".plotFunctionNode(\" + node.getPath() + \")\"],\n                                position: availableWidgetIndex\n                            }]);\n                        }\n                        group1Add[\"groups\"] = [subgroups1Add];\n\n                        group1.push(group1Add);\n                    }\n\n                    groups.push(group1);\n                }\n            }\n\n            return groups;\n        },\n\n        /**\n         * Plot a state variable given project/experiment and path + optional plot widget\n         *\n         * @param projectId\n         * @param experimentId\n         * @param path\n         * @param plotWidget - optional, if not provided a new widget will be created\n         * @param xPath - optional, if plotting xy data a path for the x axis\n         */\n        plotStateVariable: function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(projectId, experimentId, path, plotWidget, xPath) {\n                var self, inst, widget, cb, plotExternalCallback, externalInstance;\n                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                        switch (_context3.prev = _context3.next) {\n                            case 0:\n                                self = this;\n\n                                if (!(window.Project.getId() == projectId && window.Project.getActiveExperiment() != undefined && window.Project.getActiveExperiment().getId() == experimentId)) {\n                                    _context3.next = 21;\n                                    break;\n                                }\n\n                                inst = undefined;\n\n                                try {\n                                    inst = window.Instances.getInstance(path);\n                                } catch (e) {}\n\n                                // check if we already have data\n\n                                if (!(inst != undefined && inst.getTimeSeries() != undefined)) {\n                                    _context3.next = 17;\n                                    break;\n                                }\n\n                                if (!(plotWidget != undefined)) {\n                                    _context3.next = 10;\n                                    break;\n                                }\n\n                                plotWidget.plotData(inst);\n                                plotWidget.updateAxis(inst.getInstancePath());\n                                _context3.next = 15;\n                                break;\n\n                            case 10:\n                                _context3.next = 12;\n                                return G.addWidget(0);\n\n                            case 12:\n                                widget = _context3.sent;\n\n                                widget.plotData(inst).setName(path);\n                                widget.updateAxis(path);\n\n                            case 15:\n                                _context3.next = 19;\n                                break;\n\n                            case 17:\n                                cb = function () {\n                                    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                                        var i, plot;\n                                        return regeneratorRuntime.wrap(function _callee$(_context) {\n                                            while (1) {\n                                                switch (_context.prev = _context.next) {\n                                                    case 0:\n                                                        i = window.Instances.getInstance(path);\n\n                                                        if (!(plotWidget != undefined)) {\n                                                            _context.next = 6;\n                                                            break;\n                                                        }\n\n                                                        plotWidget.plotData(i);\n                                                        plotWidget.updateAxis(i.getInstancePath());\n                                                        _context.next = 11;\n                                                        break;\n\n                                                    case 6:\n                                                        _context.next = 8;\n                                                        return G.addWidget(0);\n\n                                                    case 8:\n                                                        plot = _context.sent;\n\n                                                        plot.plotData(i).setName(path);\n                                                        plot.updateAxis(path);\n\n                                                    case 11:\n                                                    case 'end':\n                                                        return _context.stop();\n                                                }\n                                            }\n                                        }, _callee, this);\n                                    }));\n\n                                    return function cb() {\n                                        return _ref2.apply(this, arguments);\n                                    };\n                                }();\n                                // trigger get experiment data with projectId, experimentId and path, and callback to plot\n\n\n                                GEPPETTO.ExperimentsController.getExperimentState(projectId, experimentId, [path], cb);\n\n                            case 19:\n                                _context3.next = 24;\n                                break;\n\n                            case 21:\n                                // we are dealing with external instances, define re-usable callback for plotting external instances\n                                plotExternalCallback = function () {\n                                    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                                        var i, t, plot;\n                                        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                            while (1) {\n                                                switch (_context2.prev = _context2.next) {\n                                                    case 0:\n                                                        i = GEPPETTO.ExperimentsController.getExternalInstance(projectId, experimentId, path);\n                                                        // if xPath is not specified, assume time\n\n                                                        if (xPath == undefined) {\n                                                            xPath = 'time(StateVariable)';\n                                                        }\n                                                        t = GEPPETTO.ExperimentsController.getExternalInstance(projectId, experimentId, xPath);\n\n                                                        if (!(plotWidget != undefined)) {\n                                                            _context2.next = 7;\n                                                            break;\n                                                        }\n\n                                                        plotWidget.plotXYData(i, t);\n                                                        _context2.next = 11;\n                                                        break;\n\n                                                    case 7:\n                                                        _context2.next = 9;\n                                                        return G.addWidget(0);\n\n                                                    case 9:\n                                                        plot = _context2.sent;\n\n                                                        plot.plotXYData(i, t).setName(path);\n\n                                                    case 11:\n                                                    case 'end':\n                                                        return _context2.stop();\n                                                }\n                                            }\n                                        }, _callee2, this);\n                                    }));\n\n                                    return function plotExternalCallback() {\n                                        return _ref3.apply(this, arguments);\n                                    };\n                                }();\n\n                                externalInstance = GEPPETTO.ExperimentsController.getExternalInstance(projectId, experimentId, path);\n\n                                if (externalInstance != undefined) {\n                                    // if not undefined, plot\n                                    plotExternalCallback();\n                                } else {\n                                    // if undefined trigger get experiment state\n                                    GEPPETTO.ExperimentsController.getExperimentState(projectId, experimentId, [path], plotExternalCallback);\n                                }\n\n                            case 24:\n                            case 'end':\n                                return _context3.stop();\n                        }\n                    }\n                }, _callee3, this);\n            }));\n\n            function plotStateVariable(_x, _x2, _x3, _x4, _x5) {\n                return _ref.apply(this, arguments);\n            }\n\n            return plotStateVariable;\n        }(),\n\n        //Returns legend with appropriate project and experiment name in brackets\n        getLegendName: function getLegendName(projectId, experimentId, instance, sameProject) {\n            var legend = null;\n            //the variable's experiment belong to same project but it's not the active one\n            if (sameProject) {\n                for (var key in window.Project.getExperiments()) {\n                    if (window.Project.getExperiments()[key].id == experimentId) {\n                        //create legend with experiment name\n                        legend = instance.getInstancePath() + \" [\" + window.Project.getExperiments()[key].name + \"]\";\n                    }\n                }\n            }\n            //The variable's experiment and projects aren't the one that is active\n            else {\n                    //get user projects\n                    var projects = GEPPETTO.ProjectsController.getUserProjects();\n\n                    for (var i = 0; i < projects.length; i++) {\n                        //match variable project id\n                        if (projects[i].id == projectId) {\n                            //match variable experiment id\n                            for (var key in projects[i].experiments) {\n                                if (projects[i].experiments[key].id == experimentId) {\n                                    //create legend with project name and experiment\n                                    legend = instance.getInstancePath() + \" [\" + projects[i].name + \" - \" + projects[i].experiments[key].name + \"]\";\n                                }\n                            }\n                        }\n                    }\n                }\n\n            return legend;\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/plot/controllers/PlotsController.js\n// module id = 1035\n// module chunks = 2 10 12\n\n//# sourceURL=webpack:///./js/components/widgets/plot/controllers/PlotsController.js?");

/***/ }),

/***/ 1038:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Controller class for popup widget. Use to make calls to widget from inside Geppetto.\n *\n * @author Jesus R Martinez (jesus@metacell.us)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(1137);\n\n    /**\n     * @exports Widgets/Popup/PopupsController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize(config) {\n            this.widgets = Array();\n            this.history = [];\n            if (config != null || undefined) {\n                this.buttonBarConfig = config.buttonBarConfiguration;\n            }\n        },\n\n        /**\n         * Creates popup widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(32).then((function (require) {\n\n                    var Popup = __webpack_require__(2344);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"Popup\", that.widgets);\n                    var name = id;\n\n                    //create popup widget\n                    var p = window[name] = new Popup({\n                        id: id, name: name, visible: true, controller: that,\n                        widgetType: GEPPETTO.Widgets.POPUP, stateless: isStateless\n                    });\n                    p.setController(that);\n                    p.setSize(394, 490);\n                    //create help command for plot\n                    p.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    //store in local stack\n                    that.widgets.push(p);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //add commands to console autocomplete and help option\n                    GEPPETTO.CommandController.updateHelpCommand(p, id, that.getFileComments(\"geppetto/js/components/widgets/popup/Popup.js\"));\n\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(p.getId(), p);\n\n                    resolve(p);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n        /**\n         * Receives updates from widget listener class to update popup widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event) {\n            //delete popup widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/popup/controllers/PopupController.js\n// module id = 1038\n// module chunks = 12\n\n//# sourceURL=webpack:///./js/components/widgets/popup/controllers/PopupController.js?");

/***/ }),

/***/ 1039:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Controller class for treevisualiser widget. Use to make calls to widget from\n * inside Geppetto.\n *\n * @module Widgets/TreeVisualizerControllerDAT\n *\n * @author Adrian Quintana (adrian.perez@ucl.ac.uk)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n    var AWidgetController = __webpack_require__(1137);\n\n    /**\n     * @exports Widgets/Connectivity/TreeVisualiserControllerDATController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = [];\n        },\n\n        /**\n         * Adds a new TreeVisualizerDAT Widget to Geppetto\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                // stateless by default\n                isStateless = true;\n            }\n\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(33).then((function (require) {\n\n                    var TreeVisualiserDAT = __webpack_require__(2357);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"TreeVisualiserDAT\", that.widgets);\n                    var name = id;\n\n                    // create tree visualiser widget\n                    var tvdat = window[name] = new TreeVisualiserDAT({\n                        id: id, name: name, visible: true, width: 260, height: 350,\n                        widgetType: GEPPETTO.Widgets.TREEVISUALISERDAT, stateless: isStateless\n                    });\n                    // create help command for plot\n                    tvdat.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n                    // store in local stack\n                    that.widgets.push(tvdat);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    // updates helpc command output\n                    GEPPETTO.CommandController.updateHelpCommand(tvdat, id, that.getFileComments(\"geppetto/js/components/widgets/treevisualiser/treevisualiserdat/TreeVisualiserDAT.js\"));\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(tvdat.getId(), tvdat);\n\n                    resolve(tvdat);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update TreeVisualizerDAT widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event, parameters) {\n            var treeVisualisersDAT = this.getWidgets();\n            // delete treevisualiser widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            } else if (event == GEPPETTO.Events.Select) {\n                //loop through all existing widgets\n                for (var i = 0; i < this.widgets.length; i++) {\n                    var treeVisualiserDAT = this.widgets[i];\n\n                    if (_.find(treeVisualiserDAT.registeredEvents, function (el) {\n                        return el.id === event;\n                    })) {\n                        var selected = GEPPETTO.SceneController.getSelection();\n                        treeVisualiserDAT.reset();\n                        //update treevisualiser with new data set\n                        treeVisualiserDAT.setData(selected[0]);\n                    }\n                }\n            }\n            // update treevisualiser widgets\n            else if (event == GEPPETTO.Events.Experiment_update) {\n                    // loop through all existing widgets\n                    for (var i = 0; i < treeVisualisersDAT.length; i++) {\n                        var treeVisualiserDAT = treeVisualisersDAT[i];\n\n                        // update treevisualiser with new data set\n                        treeVisualiserDAT.updateData(parameters.step);\n                    }\n                }\n                // update treevisualiser widgets\n                else if (event == GEPPETTO.Events.ModelTree_populated || event == GEPPETTO.Events.SimulationTree_populated) {\n                        // loop through all existing widgets\n                        for (var i = 0; i < treeVisualisersDAT.length; i++) {\n                            var treeVisualiserDAT = treeVisualisersDAT[i];\n\n                            var ev = _.find(treeVisualiserDAT.registeredEvents, function (el) {\n                                return el.id === event;\n                            });\n                            if (typeof ev !== 'undefined') {\n                                if (typeof ev.callback === 'undefined') {\n                                    //TODO: We need the event data here so we can decide if we would like to refresh or not\n                                    treeVisualiserDAT.refresh();\n                                } else {\n                                    ev.callback();\n                                }\n                            }\n                        }\n                    }\n        },\n\n        /**\n         * Retrieve commands for a specific variable node\n         *\n         * @param {Node} node - Geppetto Node used for extracting commands\n         * @returns {Array} Set of commands associated with this node\n         */\n        getCommands: function getCommands(node) {\n            var group1 = [{\n                label: \"Open with DAT Widget\",\n                action: [\"G.addWidget(Widgets.TREEVISUALISERDAT).setData(\" + node.getPath() + \")\"]\n            }];\n\n            var availableWidgets = GEPPETTO.WidgetFactory.getController(GEPPETTO.Widgets.TREEVISUALISERDAT).getWidgets();\n            if (availableWidgets.length > 0) {\n                var group1Add = {\n                    label: \"Add to DAT Widget\",\n                    position: 0\n                };\n\n                var subgroups1Add = [];\n                for (var availableWidgetIndex in availableWidgets) {\n                    var availableWidget = availableWidgets[availableWidgetIndex];\n                    subgroups1Add = subgroups1Add.concat([{\n                        label: \"Add to \" + availableWidget.name,\n                        action: [availableWidget.id + \".setData(\" + node.getPath() + \")\"],\n                        position: availableWidgetIndex\n                    }]);\n                }\n                group1Add[\"groups\"] = [subgroups1Add];\n\n                group1.push(group1Add);\n            }\n\n            var groups = [group1];\n\n            if (node.getMetaType() == GEPPETTO.Resources.COMPOSITE_TYPE_NODE && node.getWrappedObj().getVisualType() != undefined) {\n                var entity = [{\n                    label: \"Select Visual Component\",\n                    action: [\"GEPPETTO.SceneController.deselectAll();\", node.getPath() + \".select()\"]\n                }];\n\n                groups.push(entity);\n            }\n\n            if (node.getMetaType() == GEPPETTO.Resources.VISUAL_GROUP_NODE) {\n                var visualGroup = [{\n                    label: \"Show Visual Groups\",\n                    action: [\"GEPPETTO.SceneController.deselectAll();\", node.getPath() + \".show(true)\"]\n                }];\n\n                groups.push(visualGroup);\n            }\n\n            if (node.getWrappedObj().capabilities != null && node.getWrappedObj().capabilities.length > 0 && node.getWrappedObj().capabilities.indexOf('VisualGroupCapability') != -1) {\n                var visualGroup = [{\n                    label: \"Show Visual Groups\"\n                }];\n\n                var subgroups1Add = [];\n                for (var visualGroupIndex in node.getWrappedObj().getVisualGroups()) {\n                    subgroups1Add = subgroups1Add.concat([{\n                        label: \"Show \" + node.getWrappedObj().getVisualGroups()[visualGroupIndex].getName(),\n                        action: [\"GEPPETTO.SceneController.deselectAll();\", node.getPath() + \".applyVisualGroup(\" + node.getPath() + \".getVisualGroups()[\" + visualGroupIndex + \"], true)\"],\n                        position: visualGroupIndex\n                    }]);\n                }\n                visualGroup[0][\"groups\"] = [subgroups1Add];\n\n                groups.push(visualGroup);\n            }\n\n            return groups;\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/treevisualiser/treevisualiserdat/controllers/TreeVisualiserControllerDAT.js\n// module id = 1039\n// module chunks = 12\n\n//# sourceURL=webpack:///./js/components/widgets/treevisualiser/treevisualiserdat/controllers/TreeVisualiserControllerDAT.js?");

/***/ }),

/***/ 1040:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Controller class for variables visualiser widget.\n *\n * @author Dan Kruchinin (dkruchinin@acm.org)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(1137);\n\n    /**\n     * @exports Widgets/VariableVisualiser/VariableVisualiserController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = [];\n        },\n\n        /**\n         * Creates new variable visualiser widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(34).then((function (require) {\n                    var VarVis = __webpack_require__(2365);\n\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"VarVis\", that.widgets);\n                    var name = id;\n                    var vv = window[name] = new VarVis({\n                        id: id, name: name, visible: true,\n                        widgetType: GEPPETTO.Widgets.VARIABLEVISUALISER, stateless: isStateless\n                    });\n\n                    vv.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    // store in local stack\n                    that.widgets.push(vv);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //updates help command options\n                    GEPPETTO.CommandController.updateHelpCommand(vv, id, that.getFileComments(\"geppetto/js/components/widgets/variablevisualiser/VariableVisualiser.js\"));\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(vv.getId(), vv);\n                    resolve(vv);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update variable visualiser widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event, parameters) {\n            //delete a widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n            //update widgets\n            else if (event == GEPPETTO.Events.Experiment_update) {\n                    var step = parameters.step;\n                    for (var i = 0; i < this.widgets.length; i++) {\n                        this.widgets[i].updateVariable(step);\n                    }\n                }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/variablevisualiser/controllers/VariableVisualiserController.js\n// module id = 1040\n// module chunks = 12\n\n//# sourceURL=webpack:///./js/components/widgets/variablevisualiser/controllers/VariableVisualiserController.js?");

/***/ }),

/***/ 1041:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Controller class for connectivity widget. Use to make calls to widget from inside Geppetto.\n *\n * @constructor\n *\n * @module Widgets/Connectivity\n * @author Adrian Quintana (adrian.perez@ucl.ac.uk)\n * @author Boris Marin\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n    var AWidgetController = __webpack_require__(1137);\n\n    /**\n     * @exports Widgets/Connectivity/ConnectivityController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = Array();\n            this.history = [];\n        },\n\n        configureConnectivityWidget: function configureConnectivityWidget() {\n            Connectivity.prototype.configViaGUI();\n        },\n\n        /**\n         * Adds a new Connectivity Widget to Geppetto\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(30).then((function (require) {\n                    var Connectivity = __webpack_require__(2368);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"Connectivity\", that.widgets);\n                    var name = id;\n\n                    //create tree visualiser widget\n                    var cnt = window[name] = new Connectivity({\n                        id: id, name: name, visible: false, width: 500, height: 500, controller: that,\n                        widgetType: GEPPETTO.Widgets.CONNECTIVITY, stateless: isStateless\n                    });\n\n                    //create help command for connw\n                    cnt.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    //store in local stack\n                    that.widgets.push(cnt);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //add commands help option\n                    GEPPETTO.CommandController.updateHelpCommand(cnt, id, that.getFileComments(\"geppetto/js/components/widgets/connectivity/Connectivity.js\"));\n\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(cnt.getId(), cnt);\n\n                    resolve(cnt);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update TreeVisualizer3D widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event) {\n            //delete connectivity widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n            //update connectivity widgets\n            else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.UPDATE) {\n                    //loop through all existing widgets\n                    for (var i = 0; i < this.widgets.length; i++) {\n                        var cnt = this.widgets[i];\n                        //update connectivity with new data set\n                        cnt.updateData();\n                    }\n                }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/connectivity/controllers/ConnectivityController.js\n// module id = 1041\n// module chunks = 12\n\n//# sourceURL=webpack:///./js/components/widgets/connectivity/controllers/ConnectivityController.js?");

/***/ }),

/***/ 1042:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Controller class for the stackViewer widget.\n *\n * @author Robbie1977\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(1137);\n\n    /**\n     * @exports Widgets/stackViewer/stackViewerController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = Array();\n            this.history = [];\n        },\n\n        /**\n         * Creates new stack viewer widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                // stateless by default\n                isStateless = true;\n            }\n\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(31).then((function (require) {\n                    var Stack = __webpack_require__(2667);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"StackViewer\", that.widgets);\n                    var name = id;\n                    var vv = window[name] = new Stack({\n                        id: id, name: name, visible: true,\n                        widgetType: GEPPETTO.Widgets.STACKVIEWER, stateless: isStateless\n                    });\n                    vv.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n                    that.widgets.push(vv);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //updates help command options\n                    GEPPETTO.CommandController.updateHelpCommand(vv, id, that.getFileComments(\"geppetto/js/components/widgets/stackViewer/StackViewer.js\"));\n\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(vv.getId(), vv);\n                    resolve(vv);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update Button Bar widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event) {\n            //delete a widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n\n            //reset widget's datasets\n            else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.RESET_DATA) {}\n                //pass\n\n\n                //update widgets\n                else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.UPDATE) {\n                        //pass\n                    }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/stackViewer/controllers/StackViewerController.js\n// module id = 1042\n// module chunks = 12\n\n//# sourceURL=webpack:///./js/components/widgets/stackViewer/controllers/StackViewerController.js?");

/***/ }),

/***/ 1137:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n *\n * Base widget controller, all widget controllers extend this\n * @module Widgets/Widget\n * @author  Jesus R. Martinez (jesus@metacell.us)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var Backbone = __webpack_require__(59);\n    var $ = __webpack_require__(9);\n    return {\n        /**\n         * Creates base view for widget\n         */\n        View: Backbone.View.extend({\n\n            widgets: [],\n            on: true,\n            registeredEvents: null,\n            comments: [],\n            history: [],\n            staticHistoryMenu: [],\n\n            constructor: function constructor() {\n                // Call the original constructor\n                Backbone.View.apply(this, arguments);\n                registeredEvents = [];\n            },\n\n            /**\n             * Returns all plotting widgets objects\n             *\n             * @returns {Array} Array containing all plots\n             */\n            getWidgets: function getWidgets() {\n                return this.widgets;\n            },\n\n            addToHistory: function addToHistory(label, method, args, id) {\n                var elementPresentInHistory = false;\n                var widget = this.getWidgetById(id);\n\n                for (var i = 0; i < this.history.length; i++) {\n                    if (this.history[i].label == label && this.history[i].method == method) {\n                        elementPresentInHistory = true;\n                        //moves it to the first position\n                        if (widget.updateHistoryPosition) {\n                            this.history.splice(0, 0, this.history.splice(i, 1)[0]);\n                        }\n                        break;\n                    }\n                }\n                if (!elementPresentInHistory) {\n                    this.history.unshift({\n                        \"label\": label,\n                        \"method\": method,\n                        \"arguments\": args\n                    });\n\n                    this.staticHistoryMenu.push({\n                        \"label\": label,\n                        \"method\": method,\n                        \"arguments\": args\n                    });\n                }\n\n                widget.updateNavigationHistoryBar();\n            },\n\n            /**\n             * Toggles variable visualiser widget on and off\n             */\n            toggle: function toggle() {\n                if (this.widgets.length > 0) {\n                    this.on = !this.on;\n                    for (var w in this.widgets) {\n                        var widget = this.widgets[w];\n                        if (!this.on) {\n                            widget.hide();\n                        } else {\n                            widget.show();\n                        }\n                    }\n                }\n            },\n\n            /**\n             * Removes existing plotting widgets\n             */\n            removeWidgets: function removeWidgets() {\n                //remove all existing widgets\n                for (var i = 0; i < this.widgets.length; i++) {\n                    var widget = this.widgets[i];\n\n                    //remove commands\n                    GEPPETTO.CommandController.removeCommands(widget.getId());\n\n                    widget.destroy();\n\n                    i--;\n                }\n\n                this.widgets = [];\n            },\n\n            /**\n             * Get an available id for an specific widget\n             *\n             * @module WidgetUtility\n             * @param {String} prefix\n             * @param {Array} widgetsList\n             * @returns {String} id - Available id for a widget\n             */\n            getAvailableWidgetId: function getAvailableWidgetId(prefix, widgetsList) {\n                var index = 0;\n                var id = \"\";\n                var available;\n\n                do {\n                    index++;\n                    id = prefix + index;\n                    available = true;\n\n                    for (var p in widgetsList) {\n                        if (widgetsList[p].getId() == id) {\n                            available = false;\n                            break;\n                        }\n                    }\n                } while (available == false);\n\n                return id;\n            },\n\n            getWidgetById: function getWidgetById(id) {\n                for (var i = 0; i < this.widgets.length; i++) {\n                    var widget = this.widgets[i];\n                    if (widget.getId() == id) {\n                        return widget;\n                    }\n                }\n\n                return null;\n            },\n\n            /**\n             * Get the comments of a given widget file through an Ajax call. This is used to extract the comments on the methods\n             * and visualize them when using the help command.\n             *\n             * @param {String} file\n             */\n            getFileComments: function getFileComments(file) {\n                if (this.comments.length == 0) {\n                    var that = this;\n                    //retrieve the script to get the comments for all the methods\n                    $.ajax({\n                        async: true,\n                        type: 'GET',\n                        url: file,\n                        dataType: \"text\",\n                        //at success, read the file and extract the comments\n                        success: function success(data) {\n                            var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n                            that.comments = data.match(STRIP_COMMENTS);\n                        },\n                        error: function error() {\n                            console.log('error fetching file with Ajax request');\n                        }\n                    });\n                }\n                return this.comments;\n            }\n        })\n    };\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/AWidgetController.js\n// module id = 1137\n// module chunks = 2 10 12\n\n//# sourceURL=webpack:///./js/components/widgets/AWidgetController.js?");

/***/ })

});